"""This module contains functions for generating neighbors of a solution."""

import numpy as np


def swap_pizzas(
    results: np.ndarray, n_pizzas_to_swap: int, n_slices_in_pizza: int
) -> np.ndarray:
    n_slices = results.shape[0]
    n_pizzas = results.shape[1]

    n_pizzas_to_swap = min(n_pizzas_to_swap, n_slices // n_slices_in_pizza)
    n_pizzas_to_swap = max(n_pizzas_to_swap, 1)

    for _ in range(n_pizzas_to_swap):
        old_type = np.random.randint(n_slices)
        old_type = np.where(results[old_type] == 1)[0][0]
        new_type = np.random.randint(n_pizzas)

        slices_with_old_type = np.where(results[:, old_type] == 1)[0]
        np.random.shuffle(slices_with_old_type)
        slices_with_old_type = slices_with_old_type[:n_slices_in_pizza]

        results[slices_with_old_type, old_type] = 0
        results[slices_with_old_type, new_type] = 1

    return results


def swap_slices(results: np.ndarray, n_slices_to_swap: int) -> np.ndarray:
    """
    Returns a neighbor of the given solution generated by swapping n_slices_to_swap slices.
    Shuffles rows.

    Parameters
    ----------
    `results` : (n_slices, n_pizzas)
    `n_slices_to_swap` : int - number of slices to swap
    """
    n_slices = results.shape[0]

    rows_to_change = np.random.choice(n_slices, n_slices_to_swap, replace=False)
    new_rows_indices = rows_to_change.copy()
    np.random.shuffle(new_rows_indices)

    results[rows_to_change, :] = results[new_rows_indices, :]
    return results


def get_neighbor(
    results: np.ndarray,
    search_cycle_proportion: float,
    pizza_swap_proba: float = 0.5,
    n_slices_in_pizza: int = 8,
) -> np.ndarray:
    """
    Returns a neighbor of the given solution generated either by swap_pizzas() or swap_slices(),
    chosen randomly.

    Parameters
    ----------
    `results` : (n_slices, n_pizzas)
    `search_cycle_proportion` : float (0 - 1) - decides how distant the neighbor is, relative to the
    current solution (i.e. 1 means all slices/pizzas need to be swapped, 0.5 means only 50% of them
    needs to be swapped)
    `pizza_swap_proba` : probability of choosing swap_pizzas() over swap_slices()
    """
    results = results.copy()

    if np.random.rand(1) < pizza_swap_proba:
        n_to_change = (
            int(results.shape[0] * search_cycle_proportion) // n_slices_in_pizza
        )
        return swap_pizzas(results, n_to_change, n_slices_in_pizza)
    else:
        n_to_change = int(results.shape[0] * search_cycle_proportion)
        return swap_slices(results, n_to_change)
