"""This module contains functions for generating neighbors of a solution."""

import numpy as np


def swap_pizzas(results: np.ndarray, n_slices_to_change: int) -> np.ndarray:
    """
    Returns a neighbor of the given solution generated by assigning another pizza (shuffle row)
    to n_pizzas_to_change.

    Parameters
    ----------
    `results` : (n_slices, n_pizzas)
    `n_pizzas_to_change` : int - number of pizzas to swap
    """
    results = results.copy()
    n_slices = results.shape[0]
    n_pizzas = results.shape[1]

    rows_to_change = np.random.choice(n_slices, n_slices_to_change, replace=False)

    for row_index in rows_to_change:
        row = results[row_index, :]
        row[:] = 0
        row[np.random.choice(range(n_pizzas))] = 1

    # columns_to_change = np.random.choice(n_slices, n_pizzas_to_change, replace=False)
    # new_columns_indices = columns_to_change.copy()
    # np.random.shuffle(new_columns_indices)

    # results[:, columns_to_change] = results[:, new_columns_indices]
    return results


def swap_slices(results: np.ndarray, n_slices_to_swap: int) -> np.ndarray:
    """
    Returns a neighbor of the given solution generated by swapping n_slices_to_swap slices.
    Shuffles rows.

    Parameters
    ----------
    `results` : (n_slices, n_pizzas)
    `n_slices_to_swap` : int - number of slices to swap
    """
    results = results.copy()
    n_slices = results.shape[0]

    rows_to_change = np.random.choice(n_slices, n_slices_to_swap, replace=False)
    new_rows_indices = rows_to_change.copy()
    np.random.shuffle(new_rows_indices)

    results[rows_to_change, :] = results[new_rows_indices, :]
    return results


def get_neighbor(
    results: np.ndarray, search_cycle_proportion: float, pizza_swap_proba: float = 0.5
) -> np.ndarray:
    """
    Returns a neighbor of the given solution generated either by swap_pizzas() or swap_slices(),
    chosen randomly.

    Parameters
    ----------
    `results` : (n_slices, n_pizzas)
    `search_cycle_proportion` : float (0 - 1) - decides how distant the neighbor is, relative to the
    current solution (i.e. 1 means all slices/pizzas need to be swapped, 0.5 means only 50% of them
    needs to be swapped)
    `pizza_swap_proba` : probability of choosing swap_pizzas() over swap_slices()
    """
    n_to_change = int(results.shape[0] * search_cycle_proportion)
    if np.random.rand(1) < pizza_swap_proba:
        return swap_pizzas(results, n_to_change)
    return swap_slices(results, n_to_change)
